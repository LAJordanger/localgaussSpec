% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/LG_approx.R
\name{LG_approx}
\alias{LG_approx}
\title{Local Gaussian approximations.}
\usage{
LG_approx(save_dir = NULL, TS, lag_max = ceiling(3 * sqrt(length(TS))),
  LG_points, .bws_mixture = c("mixture", "local", "global"),
  bw_points = c(25, 35), .bws_fixed = NULL, .bws_fixed_only = FALSE,
  content_details = c("rho_only", "rho_log.fun", "rho_all"),
  LG_type = c("par_five", "par_one"))
}
\arguments{
\item{save_dir}{A specification of the directory to be used when
saving (and loading) data.  The default value \code{NULL} will
turn of the interaction with disk.}

\item{TS}{The time series we want to investigate by means of
techniques based on local Gaussian approximations.  Note that
this argument in the "wrapper"- and "scribe"-functions can be
given as a character vector that specifies the file where
\code{TS} from \code{TS_LG_object} was stored.}

\item{lag_max}{The number of lags to include in the analysis.  The
default value \code{ceiling(3*sqrt(length(TS)))} will probably
in most cases include more lags than actually required.  It
might thus be worthwhile to run some test and see if a smaller
value can be used instead.}

\item{LG_points}{An array that specifies the point at which it is
desired to compute the local Gaussian estimates.  Use the
function \code{LG_select_points} to create this argument.}

\item{.bws_mixture}{An argument that specifies how the global
bandwidths and those obtained by the nearest-neighbour strategy
should be combined.  The three available options are
\code{c("mixture", "local", "global")}, which have the
following effects.  The alternatives \code{local} and
\code{global} will respectively only select the nearest
neighbour or global.  These alternatives seems however to not
work well when used on some parts of the lagged pairs of
interest, i.e. the nearest neighbour values might be to "small"
in the center of the distribution, whereas the global
bandwidths seems to fail in the periphery of the distribution.
The alternative \code{mixture} attempt to resolve this by (for
each grid point) selecting the largest of the two alternative
bandwidths.  Note that the value of \code{.bws_mixture} decides
how much information that is computed, i.e. the alternative
\code{local} will turn off the computation of global
bandwidths.  However, the computations of the nearest neighbour
bandwidths will also be computed when the alternative
\code{global} is used, since it does not take long to compute
and it is that function that creates the array we need as a
mould for the result.  If the user does not make a selection,
then all three alternatives will be computed.}

\item{bw_points}{A vector, default \code{c(25, 35)}, that specifies
the percentage of the observations that we want inside the
"bandwidth-square".  If \code{.bws_mixture} is selected to be
\code{global}, then this argument will be ignored. and no
nearest neighbours will be computed.}

\item{.bws_fixed}{A vector of non-negative real values, that can be
used to specify fixed values for the bandwidths (which might be
of interest to do in a preliminary analysis).  The default
value \code{NULL} will prevent the computation of Local
Gaussian Estimates based on fixed bandwidths.}

\item{.bws_fixed_only}{A logic value, default \code{FALSE}, that
can be used to drop the rather time-consuming data-driven
estimation of bandwidths in favour of the simplified approach
where fixed bandwidths are used instead.  Note that
\code{.bws_fixed} must be specified when \code{.bws_fixed_only}
are set to \code{TRUE}.}

\item{content_details}{A character string from \code{c("rho_only",
"rho_log.fun", "rho_all")}, of which the first will be selected
if the user doesn't specify something else.  The purpose of
this argument is to decide the amount of details that should be
stored from the estimates governed by the argument
\code{LG_type}.  The default \code{rho_only} is the one needed
for the computation of the Local Gaussian Spectral Densities,
whereas \code{rho_log.fun} in addition returns the estimated
values of the logarithm of the density.  The option
\code{rho_all} will in addition return all the parameters when
\code{LG_type} is given as \code{par_five}.}

\item{LG_type}{One of \code{c("par_five", "par_one")}, i.e. should the
Local Gaussian Autocorrelations be based on the approach using
five parameters or the simplified approach using only one
parameter.  The default choice is \code{"par_five"}.}
}
\value{
The result of this function will depend upon the value of
    \code{bootstrap}.  The default case, \code{bootstrap=FALSE},
    will create a list with three components, \code{LG_type},
    \code{par_one_data} and \code{par_five_data}, see details
    below.  When \code{bootstrap=FALSE}, i.e. when this function is
    called by \code{LG_boot_approx}, then the specified data will
    be delivered directly to that function -- which then bundles
    together all the parts into one larger object.

LG_type This is simply the value of the argument
    \code{LG_type}, included in order to simplify the code later on.

par_one_data This will be null if \code{LG_type} doesn't
    contain "par_one", otherwise it will contain information about
    the Local Gaussian Approximation based on one parameter.  Note
    that this can contain \code{NA}-values if some numerical
    convergence failed, and the code later on need to take that
    into account.

par_five_data This will be null if \code{LG_type} doesn't
    contain "par_five", otherwise it will contain information about
    the Local Gaussian Approximation based on five parameters.
    This object contains an attribute \code{convergence} that
    reveals if the numerical convergence of the function
    \code{localgauss} was successful.  It's important that the code
    later on checks that this attribute is TRUE, since the
    numerical values otherwise might be erroneous.

eflag
}
\description{
Local Gaussian approximations.
}
\note{
Regarding the case where the \code{LG_type}-argument is equal
    to "par_one": The author of this package has always considered
    the "par_one"-approach to be reasonable when the aim of the
    investigation is to estimate a density at a given point.
    However, the extraction of the correlation value from the
    resulting density-estimate will in general not capture the
    local geometrical properties of the targeted distribution at
    the point of investigation.  The "par_one"-approach is as such
    (in general) a complete waste of computation resources.
}
