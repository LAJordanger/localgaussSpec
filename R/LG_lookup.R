################################################################################

#'  Look up stuff from the information object.
#'
#' This function looks up details that is needed in several functions
#' related to the interactive investigation, and was thus created to
#' avoid the duplication of code.
#'
#' @param .info The information object central for all the bookkeeping.
#'
#' @param .selected The key that identifies the part that should be
#'     visualised.
#'
#' @param .path_selection_list A list that together with
#'     \code{.selected} enables the extraction of the relevant
#'     information from \code{.info}
#'
#' @param .input The (non-reactive version) of the \code{.input}-list
#'     generated by \code{shiny} can be added here, and when that is
#'     done a revised version of the list will be returned to the
#'     workflow.  This revised version will be the basis for the
#'     plot-attribute to be used when writing dynamic documents.  The
#'     default value \code{NULL} will ignore this update.
#'
#' @return This function will update the environment of the calling
#'     function.  If \code{.input} is different from \code{NULL}, then
#'     a revised version of that will be returned to the workflow
#'     (under the name \code{.input}).  (The revised version will not
#'     change any of the values in \code{.input}, it will rather add
#'     new sublists to be used by other functions later on.)  In the
#'     other cases, the following objects will be added to the
#'     environment of the calling function: Three logical values
#'     \code{.block}, \code{.only_diagonal} and \code{.multivariate},
#'     three values related to points under investigation
#'     \code{.Horizontal}, \code{.Vertical} and \code{.Shape}, and
#'     finally \code{info_part} that will be used to create the
#'     interface.
#' @export


LG_lookup <- function(.info,
                      .selected,
                      .path_selection_list,
                      .input = NULL) {
###-------------------------------------------------------------------
    ##  Create a pointer to the environment of the calling function.
    .env <- sys.frame(which = -1)
###-------------------------------------------------------------------
    ##  Register if '.input' was given as 'NULL', if necessary
    ##  initiate (an internal) '.input'-list, else check that '.input'
    ##  is a list and tidy it up a bit.
    .input_was_NULL <- is.null(.input)
    if (.input_was_NULL) {
        .input <- list()
    } else {
        if (! is.list(.input))
            error(.argument = ".input",
                  c("This argument must either be",
                    sQuote("NULL"),
                    "or it must be a list."))
        ##  Remover 'NULL'-components that might be present when
        ##  '.input' was converted from reactive to non-reactive.
        .input <- .input[! vapply(X = .input,
                                  FUN = is.null,
                                  FUN.VALUE =  logical(1))]
    }
###-------------------------------------------------------------------
######################################################################
    ##  Initiate 'look_up' by using a copy of '.input', and update
    ##  that list.  Append this 'look_up'-list to '.input' later on.
    ##  IMPORTANT: Do not adjust the existing values of '.input', keep
    ##  those as a reference.
    look_up <- .input
    look_up$.selected <- .selected
######################################################################
###-------------------------------------------------------------------
    ##  Add basic details to '.input', starting with an investigation
    ##  of 'block' (simulated or not), 'multivariate' and
    ##  '.original_column_names' (the latter not always present).
    look_up$.block <- .info$TS_info$block
    look_up$.multivariate <- .info$TS_info$.nr_variables > 1
    look_up$.original_column_names <- .info$TS_info$.original_column_names
###-------------------------------------------------------------------
    ##  Extract the selected path-components needed for the rest of
    ##  the look-up.
    path_all_names <- switch(
        EXPR = .selected,
        TS = "TS",
        Approx = c("TS", "Approx"),
        Spectra = c("TS", "Approx", "Spectra"),
        Boot_Approx = c("TS", "Approx", "Boot_Approx"),
        Boot_Spectra = c("TS", "Approx", "Boot_Approx", "Boot_Spectra"))
    ##---
    look_up$path_all <- unlist(.path_selection_list$new[path_all_names])
    ##  Create the bookmarks to the 'eflag'-data (present for the
    ##  five-parameter local Gaussian approach.)
    .eflag_bm <- list(
        Approx = look_up$path_all["Approx"],
        Boot_Approx = look_up$path_all[c("Approx", "Boot_Approx")])
    kill(path_all_names, .path_selection_list)
###-------------------------------------------------------------------
    ##  The next part must be excluded for the 'TS'-selection.
    if (.selected != "TS") {
        ##  Extract relevant data from '.info', by adjusting 'path_all'
        look_up$.bookmark <- c(
            tail(look_up$path_all, -1),
            switch(EXPR = .selected,
                   Approx = NULL, 
                   Spectra = NULL, # Not investigated yet 
                   Boot_Approx = NULL, # Not investigated yet
                   Boot_Spectra = c("collected_data")) )
        look_up$info_part <- .info[[look_up$.bookmark]]
###-------------------------------------------------------------------
        ##  Identify details related to the level-points under
        ##  investigation, i.e. inspect the attributes of the
        ##  'LG_points'-argument.  Reminder, 2017-01-26: This code is
        ##  not optimal at the moment, as it selects the values from
        ##  the original part instead of the bootstrap part (where in
        ##  principle it could be shorter).  However, here there might
        ##  be a difference between how the behaviour should be for
        ##  the block-part and the bootstrap part.  I think an update
        ##  of the look_up$info_part might be the best option, but I don't
        ##  want to look into that for the time being.  Perhaps add a
        ##  bookmark/or a quote in the info-part that can be used to
        ##  extract 'LG_points'?
        .LG_points <- 
            .info[[look_up$.bookmark[1]]]$spy_report$envir$LG_points
        look_up$.Horizontal <- attributes(.LG_points)$Horizontal
        look_up$.Vertical   <- attributes(.LG_points)$Vertical
        look_up$.Shape      <- attributes(.LG_points)$Shape
        kill(.LG_points)
        ##  Create the logical value that reveals if only on-diagonal
        ##  points will be encountered later on.
        look_up$.only_diagonal <- nested_if(
            if_list = list(
                look_up$.Shape != "rectangle",
                identical(x = look_up$.Horizontal,
                          y = look_up$.Vertical)),
            expr_not_all_TRUE = FALSE)
    }
###-------------------------------------------------------------------
    ##  If no '.input'-list was given, add the relevant pieces to
    ##  '.env' and return nothing to the workflow.
    if (.input_was_NULL) {
        ##  Add values  to 'env'.
        .env$.block <- look_up$.block
        .env$.only_diagonal <- look_up$.only_diagonal
        .env$.multivariate <- look_up$.multivariate
        .env$.Horizontal <- look_up$.Horizontal
        .env$.Vertical <- look_up$.Vertical
        .env$.Shape <- look_up$.Shape
        .env$info_part <- look_up$info_part
        ##  Stop the function
        return(invisible(NULL))
    } else
        kill(.input_was_NULL)
######################################################################
###-------------------------------------------------------------------
    ##  Program still running? Then '.input' was given, and a bunch of
    ##  extractions must be performed.  NB: The result will depend on
    ##  the value of '.selected'.  This code is a bit "messy" as it
    ##  has to deal with a myriad of different configurations where
    ##  some values might be missing from '.input' (due to a
    ##  simplified select-interface that ignores those options where
    ##  only one value is present).
###-------------------------------------------------------------------
    ##  Extract information about the background into a new list,
    ##  start with those parts that are common for all cases of
    ##  interest, and use the information in '.selected' to include
    ##  further details.  The list 'details' will be added as an
    ##  attribute to the returned plot when called in a
    ##  non-interactive context.  The two parts 'values' and 'text'
    ##  can the be used to help 'knitr' present information about the
    ##  plot in a publication.
    details <- list(text = list(),
                    .selected = .selected)
    .from_TS_info <- c("TS_key", "block", "details", "N",
                       ".variables", ".nr_variables")
    details <- c(
        details,
        .info$TS_info[.from_TS_info])
    kill(.from_TS_info)
    ##  Add details based on the value of '.block'
    if (details$block) {
        details$nr_simulated_samples <- .info$TS_info$spy_report$envir$nr_samples
    }
    ##  Add information about univariate/multivariate observations.
    details$.multivariate <- {details$.nr_variables > 1}
###-------------------------------------------------------------------
    ##  Add informatiation about length and variables.
    details$text$length_variables <- paste(
        ifelse(test = details$block,
               yes  = "simulated",
               no   = "real"),
        " data of length ",
        details$N,
        ", ",
        ifelse(test = details$.nr_variables == 1,
               yes  = "univariate",
               no   = paste(
                   details$.nr_variables,
                   "-variate",
                   sep = "")),
        " observations.",
        sep = "")
###-------------------------------------------------------------------
    ##  If '.selected' is 'TS', then collect the components and
    ##  terminate here.
    if (.selected == "TS") {
        ##  Ensure that other tests later on does not fail.
        look_up$details$.selected <- .selected
        ##  Return required components
        .input$details <- details
        .input$look_up <- look_up
        .env$.input <- .input
        return(invisible(NULL))
    }
###-------------------------------------------------------------------
######################################################################
    ##  Program still running?  Then '.selected' is different from
    ##  'TS', and the interface details related to the plots of local
    ##  Gaussian auto/cross correlations/spectra must be covered.  In
    ##  particular add defaults for input that has been hidden due to
    ##  there only being one value to select.
######################################################################
###-------------------------------------------------------------------
    ##  Add (initial) default for 'point_type' when necessary.
    if (is.null(look_up$point_type)) 
        look_up$point_type <- "on_diag"
    ##  Some data must be extracted from the values used for the
    ##  function-calls.  Note that this solution is a bit muddled due
    ##  to the ad hoc solutions that was used in the development of
    ##  the file-hierarchy.
    .envir_bookmark <- c(look_up$path_all[{
        c(if (look_up$.block) {
              c("Approx",
                if (.selected %in% c("Boot_Approx", "Boot_Spectra"))
                    "Boot_Approx")
          } else
              c("Approx",
                if (.selected %in% c("Boot_Approx", "Boot_Spectra")) {
                    "Boot_Approx"
                } else
                    if (.selected == "Spectra")
                        "Spectra",
                if (.selected == "Boot_Spectra")
                    "Boot_Spectra"))}],
        "spy_report",
        "envir")
    ##  Create a pointer to the desired environment.
    ..env <- .info[[.envir_bookmark]]
    ##  Extract information about 'type' (when relevant).
    if (is.null(look_up$type))
        look_up$type <- ..env$LG_type
##### Reminder: To be used under development
    ##  Component still 'NULL'? Terminate and check code.
    if (is.null(look_up$type))
        error("type-component not updated.  Program stopped")
    ##  Extract information about window (when relevant).
    if (.selected %in% c("Spectra", "Boot_Spectra")) {
        if (is.null(look_up$window))
            look_up$window <- ..env$window
##### Reminder: To be used under development
        ##  Component still 'NULL'? Terminate and check code.
        if (is.null(look_up$window))
            error("window-component not updated.  Program stopped")
    } 
    kill(..env, .envir_bookmark)
###-------------------------------------------------------------------
    ##  Add information to 'details' about 'window', 'truncation'
    ##  level and 'spectrum_variant' (relevant for spectra).  This
    ##  setup ensures that the values 'NULL' occur when not present.
    details$window <- look_up$window
    details$truncation_level <-
        if (! is.null(look_up$cut))
            look_up$cut - 1
    details$spectrum_variant <-
        if (.selected %in% c("Spectra", "Boot_Spectra")) 
            look_up$spectrum_variant
###-------------------------------------------------------------------
    ##  A few defaults included to avoid errors when 'LG_lookup' is
    ##  used before the whole interface has been defined.
    if (is.null(look_up$Vi)) {
        look_up$Vi <- .info$TS_info$.variables[1]
        look_up$Vj <- .info$TS_info$.variables[1]
    }
    if (is.null(look_up$levels))
        look_up$levels <- 1
    if (is.null(look_up$levels_Line))
        look_up$levels_Line <- 1
    if (is.null(look_up$levels_Horizontal))
        look_up$levels_Horizontal <- 1
    if (is.null(look_up$levels_Vertical))
        look_up$levels_Vertical <- 1
###-------------------------------------------------------------------
    ##  Create logical values for the selection of relevant components
    ##  for the different cases that can occur.
    look_up$.auto_pair <- if (look_up$.multivariate) {
                             look_up$Vi == look_up$Vj
                         } else
                             TRUE
    look_up$.on_diagonal <-
        if (look_up$.only_diagonal) {
            TRUE
        } else if (look_up$point_type != "on_diag") {
            look_up$.Horizontal[look_up$levels_Horizontal] ==
                look_up$.Vertical[look_up$levels_Vertical]
        } else
            TRUE
    look_up$.off_diagonal <- ! look_up$.on_diagonal
    look_up$.spectrum_variant <- ! all(look_up$.auto_pair, look_up$.on_diagonal)
    look_up$.od_c_a_sqc <- all(
        if (look_up$.spectrum_variant) {
            look_up$spectrum_variant == "squared_coherence"
        } else
            FALSE,
        ! look_up$.auto_pair,
        look_up$.off_diagonal)
    ##  Finally, for the loading and plotting of data it is important
    ##  to be aware of which cases it does exist a corresponding
    ##  global value to compare with.  NOTE: Some additional tweaking
    ##  of this in 'LG_plot_load'.
    look_up$matching_global <- ! all(look_up$.auto_pair,
                                     look_up$.off_diagonal)
###-------------------------------------------------------------------
    ##  Update 'point_type' to ensure that it shows on-diagonal when
    ##  the combination of other input-arguments implies that the
    ##  point of interest is a diagonal point.  Furthermore, adjust
    ##  the value of 'levels' so the correct point can be extracted
    ##  when the call to the function is created.
    if (look_up$.on_diagonal) {
        if (look_up$point_type != "on_diag")
            look_up$levels <- which(
                sort(union(look_up$.Horizontal, look_up$.Vertical)) %in%
                look_up$.Horizontal[look_up$levels_Horizontal])
        look_up$point_type <- "on_diag"
    }
###-------------------------------------------------------------------
    ##  Collect logical values needed for 'LG_extract_df' to
    ##  understand which branch it is on.
    look_up$branch <- list(
        auto_pair = look_up$.auto_pair,
        on_diagonal = look_up$.on_diagonal,
        od_c_a_sqc = look_up$.od_c_a_sqc)
    ##  Add additional information when required.
    if (look_up$.od_c_a_sqc)
        look_up$branch$RIAP <- look_up$od_c_a_sqc
###-------------------------------------------------------------------
    ##  Extract the dimension-names needed for the creation of the
    ##  graphical controls interface.  NB: The solution is not optimal
    ##  as the structure of the info-object is a result of several ad
    ##  hoc adjustments during the development phase.  Reminder: The
    ##  subsetting of 'look_up$type' is done in order to avoid
    ##  problems during the initiation phase.
    if (.selected %in% c("Approx", "Boot_Approx")) {
        look_up$.dimnames <- look_up$info_part[[paste("dimnames.", look_up$type[1], sep = "")]][[1]]
        look_up$.available_types <- gsub(
            pattern = "dimnames.",
            replacement = "",
            x = intersect(
                x = c("dimnames.par_one", "dimnames.par_five"),
                y = names(look_up$info_part)))
    }
##### Reminder: This awfull mess is a consequence of a lousy solution
##### for the storage in the 'info'-object.  A better organised
##### structure there would simplify this part of the code
##### tremendously.
    if (.selected %in% c("Spectra")) {
        .bm <- c("dimnames_spectra", look_up$type[1])
        look_up$.dimnames <- look_up$info_part[[.bm]][[1]]
        kill(.bm)
        look_up$.available_types <- intersect(
            x = c("par_one", "par_five"),
            y = names(look_up$info_part$dimnames_spectra))
        ##  If the analogue of the squared coherence should be
        ##  included, there is a need for the following extraction.
        ##  The trigger for this setup must take into account the
        ##  differences between the auto- and cross-cases with regard
        ##  to where to check.
        look_up$.od_cross <- local({
            .cross_bookmark <- c("off_diag", "cross")
            .tmp <- look_up$.dimnames[[.cross_bookmark]]
            ##  If there is 'squared_coherence'-part, then find the
            ##  available options, otherwise return a character vector
            ##  of length zero.
            if (! is.null(.tmp$squared_coherence)) {
                .tmp <- .tmp[[c("squared_coherence", "spec")]]
                ##  Changed to desired order.
                .order <- c("Re", "negIm", "amplitude", "phase")
                .tmp[.tmp %in% .order]
            } else
                character(0)
        })
        ##  For the remaining purposes the relevant information can
        ##  always be extracted from the "on_diag"+"auto"+"Re"-node.
        look_up$.dimnames <- look_up$.dimnames[[LG_default$result$auto_node]]
        ##  Revise the value of 'look_up$cut' to the caracter needed
        ##  for the subsetting, and create text for the plot.
        if (! is.null(look_up$cut)) {
            ## ## ## ## ## look_up$cut <- as.character(sort(as.numeric(
            ## ## ## ## ##     look_up$.dimnames$cut))[look_up$cut])
#####  2017-04-12: I think this can be dropped in the new setup...
            look_up$.selected_lag <- paste(
                "m = ",
                as.numeric(look_up$cut) - 1,
                sep = "")
        }
    }
    if (.selected == "Boot_Spectra") {
        if (is.null(look_up$info_part[[c(look_up$type[1], "combined")]]))
            return("No combined files found!")
        look_up$.available_types <- names(look_up$info_part)
        ##  Find the dimension-names needed for the creation of the
        ##  graphical controls interface.
        look_up$.dimnames <- dimnames_union(
            dimnames_list = look_up$info_part[[c(look_up$type[1], "combined", "dimnames")]])
        ##  If the analogue of the squared coherence should be
        ##  included, there is a need for the following extraction.
        ##  The trigger for this setup must take into account the
        ##  differences between the auto- and cross-cases with regard
        ##  to where to check.
        look_up$.od_cross <- local({
            .cross_bookmark <- c("off_diag", "cross")
            .tmp <- look_up$.dimnames[[.cross_bookmark]]
            ##  If there is 'squared_coherence'-part, then find the
            ##  available options, otherwise return a character vector
            ##  of length zero.
            if (! is.null(.tmp$squared_coherence)) {
                .tmp <- .tmp[[c("squared_coherence", "spec")]]
                ##  Changed to desired order.
                .order <- c("Re", "negIm", "amplitude", "phase")
                .tmp[.tmp %in% .order]
            } else
                character(0)
        })
        ##  For the remaining purposes the relevant information can
        ##  always be extracted from the "on_diag"+"auto"+"Re"-node.
        look_up$.dimnames <- look_up$.dimnames[[LG_default$result$auto_node]]
        ##  Revise the value of 'look_up$cut' to the caracter needed
        ##  for the subsetting, and create text for the plot.
        if (! is.null(look_up$cut)) {
            ## ## ## ## ## look_up$cut <- as.character(sort(as.numeric(
            ## ## ## ## ##     look_up$.dimnames$cut))[look_up$cut])
#####  2017-04-12: I think this can be dropped in the new setup...
            look_up$.selected_lag <- paste(
                "m = ",
                as.numeric(look_up$cut) - 1,
                sep = "")
        }
    }
###-------------------------------------------------------------------
    ##  Update 'bw_points' when necessary.
    if (is.null(look_up$bw_points))
        look_up$bw_points <- look_up$.dimnames[["bw_points"]]
##### Reminder: To be used under development
    ##  Component still 'NULL'? Terminate and check code.
    if (is.null(look_up$bw_points))
        error("bw_points-component not updated.  Program stopped")
################################################################################

###-------------------------------------------------------------------
    ##  Create information needed for the selection of the correct
    ##  point of investigation, by computing them from '.Horizontal'
    ##  and '.Vertical', taking '.Shape' into account.
    look_up$.point_coord <-
        if (look_up$.on_diagonal) {
            if (length(union(x = look_up$.Horizontal,
                             y = look_up$.Vertical)) == 1) {
                c(look_up$.Horizontal, look_up$.Vertical)
            } else 
                local({
                    .i <- look_up$levels
                    .x <- sort(union(x = look_up$.Horizontal,
                                     y = look_up$.Vertical))[.i]
                    c(.x, .x)
                })
        } else {
            switch(EXPR = look_up$.Shape,
                   points = c(look_up$.Horizontal, look_up$.Vertical),
                   line =  local({
                       .i <- look_up$levels_Line
                       .x <- look_up$.Horizontal[.i]
                       .y <- look_up$.Vertical[.i]
                       c(.x, .y)
                   }),
                   rectangle = local({
                       .i <- look_up$levels_Horizontal
                       .j <- look_up$levels_Vertical
                       .x <- look_up$.Horizontal[.i]
                       .y <- look_up$.Vertical[.j]
                       c(.x, .y)
                   }))
        }
    ##  Update 'look_up' with the relevant entities needed later on,
    ##  i.e. a node 'levels_point' for subsetting and a node
    ##  '.selected_percentile' to be used as information on the plot.
    look_up$levels_point <- paste(
        look_up$.point_coord,
        collapse = "_")
    look_up$levels_point_reflected <- paste(
        look_up$.point_coord[2:1],
        collapse = "_")
    look_up$.selected_percentile <- paste(
        paste(
            round(x = pnorm(look_up$.point_coord),
                  digits = 3) * 100,
            "%",
            sep = ""),
        collapse = " :: ")
###-------------------------------------------------------------------
    ##  An awful hack, to be used only when blocks are present.  This
    ##  should be made into more proper code later on.
    look_up$confidence_interval_local <-
        if (look_up$.block) {
            local({
                ##  Possible replacements...?
                .replacement <- "median"
                .replacement <- "block_median"
                .replacement <- "block_mean"
                ##  Can more than one of these be present?
                .replacement <- "median,block_median,block_mean"
                ##  Perform the update:
                str_replace(string = look_up$confidence_interval,
                            pattern = LG_default$sample.prefix,
                            replacement = .replacement)
            })
#####  TASK: Fix this mess later on (if time allows for it).
        } else
            look_up$confidence_interval
    look_up$confidence_interval_global <-
        str_replace_all(
            string = look_up$confidence_interval_local,
            pattern = LG_default$contiguous.prefix,
            replacement = LG_default$sample.prefix)
###-------------------------------------------------------------------
    ##  Update 'confidence_interval' part of 'look_up' to a vector.
    look_up$confidence_interval_global <- unlist(
        str_split(
            string = look_up$confidence_interval_global,
            pattern = ","))
    look_up$confidence_interval_local <- unlist(
        str_split(
            string = look_up$confidence_interval_local,
            pattern = ","))
###-------------------------------------------------------------------
    ##  When multivariate; use the values "Vi" and "Vj" to create the
    ##  subsetting which later on is needed in order to extract a
    ##  dimension for "pairs".  Create the pair from the available
    ##  information, and store if there is a need for an adjustment of
    ##  the result (a consequence of the compactified solution used
    ##  for the storage).
    if (! look_up$.multivariate) {
        ##  Needed for univariate time series.
        look_up$pairs <- list(
            auto = .info$TS_info$.univariate_pairs,
            cross = NULL)
        ##  Version above for spectra, version below for correlations.
        look_up$pairs_ViVj <- look_up$pairs$auto
        look_up$pairs_VjVi <- look_up$pairs$auto 
        look_up$auto_cross <- "auto"
        if (! look_up$.spectrum_variant)
            look_up$spectrum_variant <- "auto"
        ##  Additional test to avoid errors in the updating phase.  (I
        ##  guess the problem is related to the way shiny does the
        ##  updating, so this is solely an ad hoc solution to avoid
        ##  error-messages.)
        if (is.null(look_up$spectrum_variant))
            look_up$spectrum_variant <- "auto"
        look_up$adjust_result <-
            {look_up$spectrum_variant %in% c("quad", "phase")}
    } else {
        ##  Identify which variables that have been selected.
        .vi <- which(.info$TS_info$.variables %in% look_up$Vi)
        .vj <- which(.info$TS_info$.variables %in% look_up$Vj)
        ##  Compute the values of interest.
        if (.vi == .vj) {
            look_up$pairs <- list(
                auto = paste(
                    .info$TS_info$.variables[c(.vi, .vj)],
                    collapse = "_"),
                cross = NULL)
            look_up$adjust_result <- FALSE
            look_up$auto_cross <- "auto"
            if (look_up$.on_diagonal)
                look_up$spectrum_variant <- "auto"
            look_up$pairs_ViVj <- look_up$pairs$auto
            look_up$pairs_VjVi <- look_up$pairs$auto 
        } else {
            look_up$pairs_ViVj <- paste(
                .info$TS_info$.variables[c(.vi, .vj)],
                collapse = "_")
            look_up$pairs_VjVi <- paste(
                .info$TS_info$.variables[c(.vj, .vi)],
                collapse = "_")
            look_up$pairs <- list(
                auto = c(
                    paste(
                        .info$TS_info$.variables[c(.vi, .vi)],
                        collapse = "_"),
                    paste(
                        .info$TS_info$.variables[c(.vj, .vj)],
                        collapse = "_")),
                cross = if (.selected == "Approx") {
                            c(look_up$pairs_ViVj,
                              look_up$pairs_VjVi)
                        } else
                            paste(
                                .info$TS_info$.variables[c(
                                                  min(.vi, .vj),
                                                  max(.vi, .vj))],
                                collapse = "_"))
            look_up$adjust_result <- {.vi > .vj}
            look_up$auto_cross <- c("auto", "cross")
        }
        kill(.vi, .vj)
    }
###-------------------------------------------------------------------
    ##  For the plots of the estimated local Gaussian auto- and
    ##  cross-correlations: Check if lag zero is needed (it will
    ##  always be one when univariate, and the value can then be
    ##  excluded from the plot), and check if negative_lags must be
    ##  included in the plot (find out if the correlation function is
    ##  even in the lag-argument, if so only plot the positive lags-
    ##  this is only relevant when univariate and on the diagonal).
    look_up$lag_zero_needed <- ! look_up$pairs_ViVj == look_up$pairs_VjVi
    look_up$negative_lags_needed <- !
        all(look_up$levels_point == look_up$levels_point_reflected,
            ! look_up$lag_zero_needed)

#####  BELOW: Not yet with a solution for all the cases of interest.
######################################################################
###-------------------------------------------------------------------
    ##  Identify paths to files of interest, based on '.selected'.
    ##  Note that the paths are relative the main directory.
    if (.selected == "Approx") {
        ##  Find the file containing the global values.
        look_up$.global_file <- paste(
            tail(x = look_up$info_part[["acr"]],
                 n = 1),
            collapse = .Platform$file.sep)
#####  Reminder: This setup has not been tuned to deal with the case
#####  where several files contains the information of interest...
        look_up$approx_file <- local({
            .select_these <- {
                look_up$info_part$data_files_df$content == look_up$type[1]}
            look_up$info_part$data_files_df$data_files[.select_these]
        })
        if (length(look_up$approx_file) != 1)
            error(c("The Approx-data is not inside one single file.",
                    "This has not been implemented yet.",
                    " Complain to the lazy programmer..."))
    }
###-------------------------------------------------------------------
    if (.selected == "Boot_Approx") {
        ##  Find the file containing the global values.
        look_up$.global_file <- paste(
            tail(x = look_up$info_part[["acr_boot"]],
                 n = 1),
            collapse = .Platform$file.sep)
#####  Reminder: This setup has not been tuned to deal with the case
#####  where several files contains the information of interest...
        look_up$approx_file <- local({
            .select_these <- {
                look_up$info_part$data_files_df$content == look_up$type[1]}
            look_up$info_part$data_files_df$data_files[.select_these]
        })
        if (length(look_up$approx_file) != 1)
            error(c("The Approx-data is not inside one single file.",
                    "This has not been implemented yet.",
                    " Complain to the lazy programmer..."))
    }
###-------------------------------------------------------------------
    if (.selected == "Spectra") {
        ##  Find the file containing the global values.
        look_up$.global_file <- paste(
            tail(x = look_up$info_part[["spectral"]],
                 n = 1),
            collapse = .Platform$file.sep)
#####  Reminder: This setup has not been tuned to deal with the case
#####  where several files contains the information of interest...
        look_up$spectra_file <- local({
            .select_these <- {
                look_up$info_part$data_files_df$content == look_up$type[1]}
            look_up$info_part$data_files_df$data_files[.select_these]
        })
        ##  Tweak it into the shape used for 'Boot_Spectra'.  This
        ##  mess should be adjusted later on to get a united treatment
        ##  for all the cases of interest.
        look_up$.file_list <- list(
            file_names = look_up$spectra_file)
    }
###-------------------------------------------------------------------
    if (.selected == "Boot_Spectra") {
        ##  Find the file containing the global values.
        look_up$.global_file <- paste(
            tail(x = look_up$info_part[["spectral_collected"]],
                 n = 1),
            collapse = .Platform$file.sep)
        ##  Find the list of files containing the combined results.
        look_up$.file_list <- look_up$info_part[[c(look_up$type[1], "combined")]]
    }
######################################################################

    

    
###-------------------------------------------------------------------
    ##  Add stuff that is common for most of the cases to be
    ##  presented, i.e. everything except the plots that shows details
    ##  related to the time series itself.
    ##  Add information about the type of local Gaussian
    ##  approximation that was used in the construction, i.e. if
    ##  the estimated local Gaussian correlations stems from a
    ##  one- or five-parameter approximation.
    details$type <- gsub(pattern = "par_",
                         replacement = "",
                         look_up$type[1])
    ##  Add information about the variables, and if it is an auto- or
    ##  cross-case that is under investigation.  Note that the
    ##  'auto_cross' in this case should be anew, since the
    ##  'auto_cross' part of 'look_up' can contain both values.
    details$Vi <- look_up$Vi
    details$Vj <- look_up$Vj
    details$auto_cross <- ifelse(
        test = {look_up$Vi == look_up$Vj},
        yes  = "auto",
        no   = "cross")
    ##  Add information about the coordinates, both as numbers and
    ##  as percentiles of the standard normal distribution.
    details$.point_coord <- look_up$.point_coord
    details$.point_coord_percentile <- pnorm(details$.point_coord)
    details$.selected_percentile <- look_up$.selected_percentile
    ##  Add the bandwidth, as a character.  Note: This is not
    ##  necessarily a number, it could also represent a
    ##  percentage.  Some care must thus be taken when the text
    ##  version is to be created.  (The subsetting with 1 is
    ##  included in order to avoid a warning from a test later on
    ##  in the initalising part of the shiny-interface.)
    details$bandwidth <- look_up$bw_points[1]
    ##  Add details needed when dealing with the plots of local
    ##  Gaussian auto- and cross-correlations.
    if (.selected %in% c("Approx", "Boot_Approx")) {
        details$lag_zero_needed <- look_up$lag_zero_needed
        details$negative_lags_needed <- look_up$negative_lags_needed
    }
###-------------------------------------------------------------------
    ##  See if a bootstrap is present, and if so extract information
    ##  about 'boot_type', 'block_length' and 'nb' (number of
    ##  bootstrap replicates).
    details$boot <- all(
        ! details$block,
        .selected %in% c("Boot_Approx", "Boot_Spectra"))
    if (details$boot) {
        .boot_bookmark <- c(
            look_up$path_all[c("Approx", "Boot_Approx")],
            "spy_report",
            "envir")
        .boot_info <-  .info[[.boot_bookmark]]
        for (.arg in c("boot_type", "block_length", "nb"))
            details[[.arg]] <- .boot_info[[.arg]]
        kill(.boot_bookmark, .boot_info, .arg)
    }
###-------------------------------------------------------------------
    ##  See if a confidence interval is present, and if so find the
    ##  value that was used.
    details$confidence_interval <- ! is.null(look_up$confidence_interval)
    if (details$confidence_interval) 
        details$CI_percentage <- local({
            .min_max <- stringr::str_detect(
                                     string = look_up$confidence_interval,
                                     pattern = "min")
            if (.min_max) {
                "min_max"
            } else
                as.numeric(
                    strsplit(x = look_up$confidence_interval,
                             split = "low_")[[1]][2])
        })
###-------------------------------------------------------------------
    ##  Specify if the plot shows correlations or a spectrum.
    details$content <-
        if (.selected %in% c("Approx", "Boot_Approx")) {
            "correlations"
        } else
            "spectrum"
###-------------------------------------------------------------------
    ##  Register if the point lies on the diagonal
    details$.on_diagonal <- look_up$.on_diagonal
###-------------------------------------------------------------------
    ##  Register the original variable names.
    details$.original_column_names <- look_up$.original_column_names
###-------------------------------------------------------------------
######################################################################
    ##  Add text-information based on 'details_values' to simplify the
    ##  explanation of the plots that is investigated.
######################################################################    
###-------------------------------------------------------------------
    ##  Add information about the line-types and colours that is used
    ##  for the different configurations.
    details$text$local_colour <- "blue"
    details$text$global_colour <- "red"
    details$text$simulated_data__lty <- "dashed line"
    details$text$real_data_lty <- "line"
###-------------------------------------------------------------------
    ##   Add a description of the content.  This specifies first
    ##   auto/cross and correlations/spectrum, then it mentions
    ##   the point (bot has ordinary coordinates and percentiles).
    ##   If the plot is of correlations, additional information
    ##   will be added based on 'lag_zero_needed' and
    ##   'negative_lags_needed'.
    details$text$content <- paste(
        c("A plot of the local Gaussian ",
          details$auto_cross, 
          "-",
          details$content,
          if (.selected %in% c("Spectra", "Boot_Spectra"))
              c(" (truncated at lag ",
                details$truncation_level,
                ", using the ",
                details$window,
                " lag-window kernel for smoothing)"),
          " at the point (",
          paste(details$.point_coord,
                collapse = ", "),
          ").  The coefficients of this point corresponds to the",
          " standard-normal percentiles ",
          details$.selected_percentile,
          ".",
          if (.selected %in% c("Approx", "Boot_Approx")) 
              c(if (! details$lag_zero_needed)
                    c("  Note that the lag zero component always is one",
                      " in this case, and it has thus been dropped from the plot."),
                if (! details$negative_lags_needed)
                    c("  The local correlations are even in the lag-argument",
                      " in this case (since the point lies on the diagonal),",
                      " so only positive lags are shown in the plot.")),
          if (.selected %in% c("Spectra", "Boot_Spectra"))
              c("  The ",
                details$text$global_colour,
                " part represents the ordinary global ",
                details$auto_cross,
                "-spectrum (included for comparison)",
                " whereas the ",
                details$text$local_colour,
                " part shows the spectra computed from the local Gaussian ",
                details$auto_cross,
                "-correlations.  Note that the local spectrum is even in the",
                " frequency-argument, so only positve frequencies are ploted.")),
        collapse = "")
###-------------------------------------------------------------------
    ##  Add information about bandwidth and type of local Gaussian
    ##  approximation.  Add a warning if the one-parameter local
    ##  Gaussian approximations are used.
    details$text$computations <- paste(
        c("The computations are based on the correlations obtained from",
          " a local fitting, at the point (",
          paste(details$.point_coord,
                collapse = ", "),
          "), of a ",
          details$type,
          "-parameter Gaussian approximation to the probability",
          " density functions of lagged pairs of pseudo-normalised observations,",
          " where the bandwidth ",
          details$bandwidth,
          " was used in the estimation algorithm (for all the lags).",
          if (details$type == "one")
              c("  **WARNING:**  The one-paramet local Gaussian",
                " approximation are included as an option, but it will",
                " in general fail to capture the local properties",
                " of interest.  Use the five-parameter approach instead!")),
        collapse = "")


#####  Reminder: This needs to be tweaked a bit to cover the cases
#####  where the bandwidth is given as a percentage...  Trigger below
#####  to ensure that these cases will be taken care of.
    if (is.na(as.numeric(details$bandwidth)))
        error(c("The value in ",
                sQuote("look_up$bw_points"),
                "is not a numerical value.",
                "Update code for extraction in this case!"))
###-------------------------------------------------------------------
    ##  Add CI-text (when relevant)
    if (details$confidence_interval) {
        details$text$CI <- paste(
            if (details$CI_percentage == "min_max") {
                "Pointwise max and min values based on "
            } else
                paste(details$CI_percentage,
                      "\\% pointwise confidence interval based on ",
                      sep = ""),
            if (details$block) {
                paste(details$nr_simulated_samples,
                      " independent samples.",
                      sep = "")
            } else
                paste(details$nb,
                      " ",
                      details$boot_type,
                      "-bootstrap replicates, having block-length ",
                      details$block_length,
                      ".",
                      sep = ""),
            sep = "")
    }
###-------------------------------------------------------------------
    ##  Add information about the type of the plot, that covers both
    ##  correlations and spectra.
    details$text$plot_type <-  paste(
        c("local Gaussian ",
          if (.selected %in% c("Approx", "Boot_Approx")) {
              c(details$auto_cross,
                "-")
          } else {
              c(if (details$auto_cross == "auto")
                    "auto-",
                if (any(details$auto_cross == "cross",
                        all(! details$.on_diagonal,
                            details$auto_cross == "auto")))
                    switch(EXPR = details$spectrum_variant,
                           auto = "",
                           co   = "co",
                           quad = "quadrature ",
                           amplitude = "amplitude ",
                           phase = "phase ",
                           "  **NO DESCRIPTION** "))
          },
          details$content),
        collapse = "")
    details$text$plot_type_YiYj <- paste(
        if (details$auto_cross == "auto") {
            c(" of ",
              details$Vi)
        } else c(" between ",
                 details$Vi,
                 " and ",
                 details$Vj),
        collapse = "")
###-------------------------------------------------------------------
    ##  Add information about whether or not the numerical convergence
    ##  could be trusted, i.e. if 'eflag' was 0 when the
    ##  five-parameter local Gaussian approach was used.  If the
    ##  one-parameter local Gaussian approach is used, state that the
    ## result is crap.
    details$text$trust_the_result <-
        if (details$type == "one") {
            "Computations based on 1-parameter approach.  Use 5-parameter instead!"
        } else {
            local({
                .convergence_orig <- .info[[.eflag_bm[["Approx"]]]]$convergence
                .convergence_boot <- .info[[.eflag_bm[["Boot_Approx"]]]]$convergence
                ##  Identify the relevant part.
                .part <- ifelse(
                    test = details$.on_diagonal,
                    yes  = "on_diag",
                    no   = "off_diag")
                ##  Extract convergence-information.
                .convergence <- all(
                    vapply(X = .convergence_orig,
                           FUN = function(x)
                               x[[.part]],
                           FUN.VALUE = logical(1)),
                    vapply(X = .convergence_boot,
                           FUN = function(x)
                               x[[.part]],
                           FUN.VALUE = logical(1)))
                ## Create the text to be used, and add the convergence
                ## status as an attribute.
                .tmp <- if (.convergence) {
                    "NC = OK"
                } else
                    "NC = FAIL"
                attributes(.tmp)$convergence <- .convergence
                .tmp
            })
        }
###-------------------------------------------------------------------
    ##  Add 'details' to 'look_up', and add 'look_up' to '.input',
    ##  then add '.input' to the calling function (this will overwrite
    ##  an existing '.input'-object if it already exists).  Finally
    ##  return an invisible 'NULL' from this function
    look_up$details <- details
    ## ## ## ## ## ## .input$details <- details
    .input$look_up <- look_up
    .env$.input <- .input
    invisible(NULL)
}
